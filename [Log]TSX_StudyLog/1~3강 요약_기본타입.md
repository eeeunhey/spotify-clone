

# 💬 TypeScript 기초 정리 (원형 유지 + 예시 보강)

---

## 1️⃣ 개요

1. **포용력이 넓다.**
   타입이 동적으로 변환되기 때문에 **JavaScript는 동적 타입 언어**라고 한다.

2. **다 받아와서 오류남.**
   → 어디서 어떤 타입이 들어왔는지 감이 안 오기 때문.

3. **금쪽이 같은 코드, 타입을 지정한다.**
   → TypeScript는 타입을 명시적으로 지정한다.

4. **타입 에러를 줄이고 예측 가능해진다.**
   → 코드 안정성, 유지보수성 향상.

---

## 2️⃣ TS 원시 타입 (Primitive Types)

> 모두 **소문자**로 작성해야 함.

| 구분  | 타입        | 설명             |
| --- | --------- | -------------- |
| 1   | string    | 문자열            |
| 2   | number    | 숫자             |
| 3   | boolean   | true / false   |
| 4   | null      | 비어 있는 값        |
| 5   | undefined | 정의되지 않은 값      |
| --- | ---       | ---            |
| 6   | symbol    | 고유 식별자 (예외 타입) |
| 7   | bigint    | 큰 정수형 (예외 타입)  |

```ts
let a: number = 3;
a = 4;
a = 9.0; // ✅ number 타입이므로 정수/실수 모두 가능

// ❌ 다른 타입 대입 시 에러 발생
a = "5"; // Error: string → number 불가
```

```ts
// 타입 추론 가능
let b = true; // boolean으로 추론됨

// 하지만 가능한 명시적으로 타입 지정 권장
let c: boolean = true;
```

---

### 💡 null / undefined 차이

```ts
let b: null; // 왜 지정해?
// 초기값이 null일 때 사용. "현재 값이 비어있음"을 명시함.

let c: undefined;
// 값이 아직 정의되지 않음. 나중에 값이 들어올 예정인 변수에 사용.
```

---

### 💬 예시 함수

```ts
function double(n: number) {
  return n * 2;
}

console.log(double(4)); // ✅ 8
```

> ⚙️ Node.js는 JS만 실행 가능하므로, TypeScript 파일(`.ts`)을 실행하려면
>
> ```bash
> tsc main.ts
> node main.js
> ```
>
> 처럼 컴파일 후 실행해야 한다.
> (TS는 JS 개발자를 위한 템플릿 언어로, 실행 시 JS 코드로 변환된다.)

---

## 3️⃣ TS 객체 & 배열 & 튜플

---

### 🧩 객체 타입

```ts
// 객체 타입 정의
let b: { name: string } = { name: "hey" };
```

---

### 💡 선택적 체이닝 (Optional Property + Optional Chaining)

데이터 성질이 일정하지 않아, API 응답 시 필수 값이 아닐 수 있다.
예: name은 올 수도 있고, age는 없을 수도 있는 경우

```ts
let b: { name: string; age?: number } = { name: "Eunhye" };

// 선택적 체이닝 (?.)
console.log(b.age?.toFixed(0)); // ✅ age가 있으면 실행, 없으면 undefined 반환 (에러 없음)
```

```ts
// ❌ 일반 접근 시 에러 발생 가능
// console.log(b.age.toFixed(0)); 
// Error: Cannot read properties of undefined
```

---

### 🔒 읽기 전용 (readonly)

```ts
let user: { readonly id: string; name: string } = {
  id: "U123",
  name: "Kim",
};

user.name = "Lee"; // ✅
user.id = "U456";  // ❌ Error (readonly 속성)
```

---

## 4️⃣ 배열 지정

```ts
let fruits: string[] = ["banana", "apple"]; // ✅
let numbers: number[] = [1, 2, 3, 4];      // ✅

// ❌ 다른 타입 추가 시 에러
numbers.push("apple");
// Error: Argument of type 'string' is not assignable to parameter of type 'number'

// 제네릭 문법
let numbers2: Array<number> = [1, 2, 3, 4];
```

---

### 👥 여러 객체 배열

```ts
let students: { name: string; age: number }[] = [
  { name: "eunhe", age: 24 },
  { name: "eunji", age: 34 },
];

// ❌ 누락 시 에러 발생
// { name: "minhee" }  // Error: Property 'age' is missing
```

선택적 체이닝을 이용하면 다음처럼 가능하다 👇

```ts
let students: { name: string; age?: number }[] = [
  { name: "eunhe" },
  { name: "eunji", age: 34 },
  { name: "minhee", age: 30 },
];
```

---

## 5️⃣ 튜플 (Tuple)

> 배열과 비슷하지만 **길이와 순서가 고정**된다.
> 제약이 많지만 그만큼 타입이 엄격하다.

```ts
let tuple: [string, number];

tuple = ["eunhye", 26];         // ✅
tuple = ["eunhye", 26, "추가"]; // ❌ 길이 초과
tuple = [26, "eunhye"];         // ❌ 순서 오류
```

---

## 6️⃣ 유니온 타입 (Union)

> 여러 타입을 허용할 수 있다.

```ts
let prompt: string | string[];

prompt = "안녕"; // ✅
prompt = ["안녕", "하세요"]; // ✅
prompt = 123; // ❌ Error: number는 불가
```

---

## 7️⃣ 나만의 타입 정의하기

---

### 🧱 interface 방식

```ts
interface MyInterType {
  name: string;
  age: number;
  // isStudent?: boolean; // 필요 없으면 제거 가능
}
```

📌 **상황**
객체 타입만 정의할 때 사용하며, **field(속성)** 형태로 작성해야 한다.
보통 **클래스나 객체 타입**과 함께 사용된다.

---

### 🔗 확장 관계 (extends)

```ts
interface IPerson {
  name: string;
  age: number;
}

interface IForeigner extends IPerson {
  nationality: string;
}
```

→ 상속하면 `name`, `age`를 다시 안 써도 됨.

```ts
let american: IForeigner = {
  nationality: "American",
  name: "Jacob",
  age: 23,
  // gender: "F", ❌ 정의되지 않은 속성
};
```

---

### ⚙️ type 방식

```ts
// 원시 타입, 튜플, 유니온 모두 가능
type MyType = {
  name: string;
  age?: number;
};

type Tuple = [number, string, boolean];
```

---

### 🧩 type과 interface 혼합

```ts
type TForeigner = IPerson & { nationality: string };
type TForeignerAlt = IPerson | { nationality: string };

// ❌ interface 안에서 type 유니온 바로 사용 불가
// interface NewType { number | string } // X
// 필드 내부에서는 가능
interface NewType {
  field: number | string; // ✅
}
```

---

### 💡 교차(&) vs 유니온(|) 차이 예시

```ts
// | : IPerson 이거나 {nationality, period} 이거나 둘 중 하나 가능
type TForeignerOr = IPerson | { nationality: string; period: Date };
let america1: TForeignerOr = { nationality: "American", period: new Date() }; // ✅

// & : IPerson을 반드시 포함해야 함 (확장형)
type TForeignerAnd = IPerson & { nationality: string; period: Date };
let america2: TForeignerAnd = {
  name: "Jacob",
  age: 23,
  nationality: "American",
  period: new Date(),
}; // ✅

// ❌ 일부만 있으면 에러
// let america3: TForeignerAnd = { nationality: "American", period: new Date() };
// Error: Property 'name' is missing
```

---

## ✅ 핵심 정리

| 구분        | 의미               | 특징                 |
| --------- | ---------------- | ------------------ |
| interface | 객체 타입 정의         | 클래스, 객체와 자주 연동됨    |
| type      | 원시, 유니온, 튜플 등 범용 | 더 유연하고 간결함         |
| extends   | 인터페이스 상속         | 중복 필드 줄임           |
| &         | 교차 타입            | 모든 속성 포함           |
| |         | 유니온 타입           | 둘 중 하나만 포함         |
| ?.        | 선택적 체이닝          | undefined일 때 안전 접근 |
| readonly  | 읽기 전용            | 값 수정 방지            |

---
