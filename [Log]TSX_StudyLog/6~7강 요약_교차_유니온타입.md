
## 🔍 코드 요약

```ts
// 1️⃣ 타입(type) 버전
type Product = {
  id: string;
  name: string;
  price: number;
  discount?: number;
};

type DiscountProduct = Product & { discountRatio: number };

// 2️⃣ 인터페이스(interface) 버전
interface Product {
  id: string;
  name: string;
  price: number;
}

interface DiscountProduct extends Product {
  discountRatio: number;
}
```

---

## 🧩 핵심 비교

| 구분          | `extends` (interface)                 | `&` 교차 타입 (type)                       |
| ----------- | ------------------------------------- | -------------------------------------- |
| **사용 위치**   | `interface`에서 상속할 때 사용                | `type`에서 여러 타입을 합칠 때 사용                |
| **형태**      | `interface B extends A`               | `type B = A & { ... }`                 |
| **의미**      | 부모 인터페이스의 속성을 자식이 “상속받음”              | 여러 타입을 “병합(combine)”해서 새 타입 생성         |
| **충돌 시 처리** | 같은 이름의 속성이 있으면 ❌ 에러 발생                | 같은 이름의 속성이 있으면 ⚠️ 교차 불가능하거나 `never` 발생 |
| **확장성**     | 여러 인터페이스를 extends 가능 (`extends A, B`) | 여러 타입을 & 로 묶을 수 있음 (`A & B & C`)       |
| **선언 병합**   | ✅ 가능 — 같은 이름의 interface가 자동 합쳐짐       | ❌ 불가능 — 같은 이름의 type은 재정의 에러            |
| **사용 예시**   | 객체 설계, 클래스 상속 구조에 적합                  | 복잡한 유니온/교차 타입 조합에 적합                   |

---

## 📘 예시로 이해하기

### 1️⃣ interface + extends

```ts
interface Product {
  id: string;
  name: string;
  price: number;
}

interface DiscountProduct extends Product {
  discountRatio: number;
}
```

👉 `DiscountProduct`는 `Product`의 모든 속성을 “상속받고” `discountRatio`를 추가합니다.

**결과:**

```ts
{
  id: string;
  name: string;
  price: number;
  discountRatio: number;
}
```

---

### 2️⃣ type + &

```ts
type Product = {
  id: string;
  name: string;
  price: number;
};

type DiscountProduct = Product & { discountRatio: number };
```

👉 `Product` 타입과 `{ discountRatio: number }` 타입을 **합친다 (병합)**
둘 다 객체 타입이므로 같은 구조의 새로운 타입이 만들어집니다.

**결과:**

```ts
{
  id: string;
  name: string;
  price: number;
  discountRatio: number;
}
```

---

## ⚡ 차이 정리 한 줄 요약

> 🔹 `extends` → 부모 인터페이스의 속성을 “상속”받는 구조적 확장
> 🔹 `&` → 여러 타입을 “합쳐서” 새로운 복합 타입 생성

---

## ✅ 언제 어떤 걸 쓰면 좋은가?

| 상황                                         | 추천 방식                 |
| ------------------------------------------ | --------------------- |
| 객체 설계 (OOP 느낌, 클래스와 호환)                    | `interface + extends` |
| 유연한 타입 조합, 유니온/교차 사용                       | `type + &`            |
| 여러 번 선언해 확장할 가능성 있음                        | `interface`           |
| 유틸리티 타입(`Pick`, `Omit`, `ReturnType` 등) 사용 | `type`                |

---



# 1) 교차 타입(&)은 겹치는 속성이 없어도 사용 가능

```ts
type Popularity = { rate: number };
interface Review { review: number }

type Filter = Popularity & Review;

let filter: Filter = {
  rate: 2.3,
  review: 3,
};
```

* **포인트**: `&`는 “합집합(모두 필요)”이라서, **겹치는 키가 없어도** 두 타입의 속성을 **모두 갖는** 새 타입을 만든다.

---

# 2) 교차 타입에서 **동명이인(같은 키) 충돌**이 나면?

```ts
type Popularity = { rate: number };
interface Review { rate: string }  // ← 같은 key(rate)지만 타입이 다름

type Filter = Popularity & Review;  // rate: number & string → never (불가능)

let filter: Filter = {
  // rate에 어떤 값도 넣을 수 없음 (never)
  rate: 2.3,     // ❌ 에러
};
```

* **결과**: `number & string`은 공통부분이 없어 **`never`** 가 되어 **실제로는 만들 수 없는 타입**이 된다.
* **에러 타이밍**: 선언 자체는 되지만, **값을 만들 때** 에러가 터진다.

### 해결 방법 3가지

1. **한쪽 타입을 바꿔 타입을 맞춘다**
2. **키를 다르게 분리**한다 (예: `rateScore`, `rateLabel`)
3. **상황상 둘 다 필요하다면 유니온으로 바꾼다**

   ```ts
   type Popularity = { rate: number };
   interface Review { rate: number | string } // 혹은 string → number로 정리
   ```

---

# 3) interface는 **여러 개 extends 가능**, 하지만 충돌 나면 즉시 에러

```ts
interface A { rate: number }
interface B { rate: string }

interface C extends A, B { } 
// ❌ 에러: 같은 프로퍼티(rate)의 타입이 서로 다름 (number vs string)
```

* `type` 교차와 다르게 **선언 시점에서 에러**가 난다(더 빠르게 발견 가능).

---

# 4) 쇼핑몰 예시 — “세일 상품”을 기존 `Product`에 **옵셔널로만** 섞으면 생기는 문제

## (문제 되는 타입)

```ts
interface Product {
  img: string;
  name: string;
  description: string;
  // ❗ 세일만 갖는 정보인데 여기다 억지로 넣으면, 나중에 코드가 지저분해짐
  discountPercent?: number;  
}

type ApiResponse = {
  products: Product[];
  salseProducts: Product[]; // 오타: salse → sales
};
```

* 이렇게 두면 `products`도, `salesProducts`도 **같은 타입**이어서

  ```ts
  apiResponse.products.map(p => p.discountPercent) // 전부 optional → 분기 필요
  ```

  매번 `if (p.discountPercent)` 같은 **조건 분기**가 생김.
* 또한 예시처럼 `apiResponse.map(...)`는 **배열이 아니라 객체**여서 런타임 에러가 난다.
  올바른 접근은 `apiResponse.products.map(...)`.

## ✅ 더 좋은 모델링 2가지

### A안) **타입을 분리**: 세일 상품은 별도 타입 + 배열도 구분

```ts
interface Product {
  img: string;
  name: string;
  description: string;
}

interface SalesProduct extends Product {
  discountPercent: number; // 세일이면 “필수”가 더 자연스러움
}

type ApiResponse = {
  products: Product[];
  salesProducts: SalesProduct[];  // ✅ 오타 수정 및 분리
};

// 사용 예
apiResponse.salesProducts.map(p => p.discountPercent); // 분기 불필요
```

### B안) **하나의 리스트로 받고, 식별자(discriminant)로 구분**

* 백엔드가 “한 배열”로 보내고 싶다면 **명시적 구분 필드**를 추가하자.

```ts
type NormalItem = {
  kind: 'normal';
  img: string;
  name: string;
  description: string;
};

type SaleItem = {
  kind: 'sale';
  img: string;
  name: string;
  description: string;
  discountPercent: number;
};

type CatalogItem = NormalItem | SaleItem;

type ApiResponse = {
  items: CatalogItem[];
};

// 사용 예
apiResponse.items.map(item => {
  if (item.kind === 'sale') {
    return item.discountPercent;  // 타입 내로잉으로 안전하게 접근
  }
  return null;
});
```

* **장점**: 한 배열로 받아도 타입이 명확하고, 분기 시 **자동 타입 좁히기(내로잉)** 가 된다.
* **실무 팁**: 프론트가 처리하기 쉽도록 **백엔드와 미리 합의**해서 `kind` 같은 구분 키를 넣는 게 가장 깔끔하다.

---

# 5) “extends vs &” 현업 관점 요약

* **여러 객체 설계 + 재사용 + 선언 병합 필요** → `interface` + `extends`
* **유니온/교차/유틸리티 타입 조합 많은 모델링** → `type` + `&`
* **같은 키가 다른 타입으로 겹치면**

  * `interface extends`는 **선언 즉시 에러** (빨리 잡힘)
  * `type &`는 **교차 결과가 `never`** 가 되어 **값 만들 때 에러**

---





### 유니온 타입

음악 서치 웹을 만든다고 해보자

```ts
type Track = {
    title:string, //음원이름
    releaseDate:string, // 음원 발매일
}

type Artist = {
    name:string.  // 가수이름
    releaseDate:sring, // 데뷔날짜
}

type searchResult = Track | Artist

interface SearchResponse {
    searchResult: Track | Artist
}

let results : SearchResult[]=[{title:"hello", releaseDate"2024"},{name:"hello", releaseDate: "2025"}]
음원이름:hello 발매날짜: 2024
가수이름:hello 데뷔일:2025
인 상황이다 나도 헷갈리는데.... 그래도 돌아간다 나중에 문제가 많다

타입을 정의를 해줘야 한다 나중에

fuction getName (result:Track|Artist) {
    return result.name
    // 에러 발생 둘 중에 name를 가지고 있지 않아서 에러 발생

    return result.releaseDate 에러안남
}
```

🟡 **추가 설명**

* `Track | Artist` 는 두 타입 중 **하나**일 수 있다는 뜻이다.
* `name`은 `Artist`에만 존재하고 `Track`에는 없기 때문에 접근 시 에러 발생.
* 반면 `releaseDate`는 **둘 다 가지고 있기 때문에** 공통 속성으로 간주되어 에러가 나지 않는다.
* 이런 경우, **타입 좁히기(type narrowing)** 를 사용해서 어떤 타입인지 구분해줘야 한다.

---

### 타입 좁히기를 적용해보자

#### 1. typeof 타입을 알려줘라

```ts
type SearchType = number|string;

funstion searchByKeyword(keyword:SearchType):string {
    // 숫자로 들어오는 타입은 스트링으로 바꿔주기
    만약에 키워드가 넘버이면 문자로 바꿔줘라
    if(typeof keyword === "number") return keyword.toString()
    return keyword
}

// 타입이 무엇인지 모를 때 사용 
console.log(searchByKeyword(3));
출력 3 나오는데 문자인지 숫자인지 알수가 없음
console.log(searchByKeyword(3), typeof searchByKeyword(3));
출력 : 3 string
타입을 알려준다

단점 : 원시타입만 가능한다 그 외는 못잡는다 

type SearchType = number|string|object;
funstion searchByKeyword(keyword:SearchType){
    console.log(typeof keyword);
}
searchByKeyword({name:"3"});
출력 : object 
정확히 어떤객체인지에 대해 못보여준다
```

🟢 **추가 설명**

* `typeof`는 **string, number, boolean, object, undefined, function, symbol, bigint** 등의 기본 타입만 구분 가능.
* 직접 만든 객체(`{ name: "3" }`)는 전부 `"object"`로 나오기 때문에 정확한 타입을 알 수 없음.
* 그래서 객체의 구체적인 형태를 구분할 때는 다른 방법(`instanceof`, `in`, 사용자 정의 타입가드 등)을 써야 함.

---

#### 2. instanceof

객체타입 검사가 가능하다 js 내장된것만 잡아준다

```ts
type Period= {
    start:string,
    end:string
}

type SearchType = Period | Date

function getDate(day: SearchType(입력)):Date(출력) {
    retrun day
}
SearchType을 받아서 Date 하나를 반환한다
day가 SearchType이야 둘다 있어 흠.... 뭘까... 

만약에 Date가 들어왔다면 문제 없음
getDate(new Date("2024-01-01"))

Period 내가 만든 객체값이 들어오면 문제발생
getDate({start:"2024-01-01", end:"2024-03-01"})

function getDate(day: SearchType(입력)):Date(출력) {
    if(day instanceof Period) return new Date(day.start)
    retrun day
} 오류남 내가 만든객체 모른다 

function getDate(day: SearchTyp):Date {
    if(day instanceof Date) return day
    retrun new Date(day.start)
}

getDate({start:"2024-01-01", end:"2024-03-01"})
출력 : 2024-01-01
```

🟢 **추가 설명**

* `instanceof`는 **클래스로 만들어진 객체**(`Date`, `Array`, `Error` 등)에만 동작한다.
* 직접 정의한 리터럴 객체(`{ start: "2024-01-01" }`)는 **생성자 함수가 없기 때문에 검사 불가능**.
* 그래서 `day instanceof Period`는 항상 `false`가 된다.
* 대신 `if ("start" in day)`처럼 **in 연산자**나 사용자 정의 타입가드를 써야 `Period`인지 판별 가능하다.

예를 들어 이렇게 쓸 수 있다:

```ts
function getDate(day: Period | Date): Date {
  if ("start" in day) return new Date(day.start);
  return day;
}
```

---
