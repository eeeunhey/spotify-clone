```ts
type Track = {
    title:string, //음원이름
    releaseDate:string, // 음원 발매일
}

type Artist = {
    name:string.  // 가수이름
    releaseDate:sring, // 데뷔날짜
}

function getName(rresult:Track|Artist) {
    if("title" in result ) return result.title

    if("name" in result) return result.name
}
//필드를 통해서 무슨 값인지 확인할 수 있다

```

4. is 타입 지정하기

타입 가드 함수라고 한다


```ts

funtion 타입가드(변수: any):변수 is 특징타입 {
    return 조건식;
}

```

무저건 Track 을 반환하게 한다
as 임시로 가정한다라는 의미로 쓰인다
➡️ “result 안에 title이 없으면 true 반환”.
하지만 이건 “Track이 아니다” 라는 뜻이에요. Track 아닌걸로 반환(Artist)
(Track이면 title이 있어야 하니까.)

➡️ result 안에 title이 있으면 true 반환
return (result as Track).title !== undefined; → ✅ “Track이 맞다”를 반환

```ts
 
function isTrack(result: Track|Artist):result is Track {
    return (result as Track).title !== undefined;
}

function isArtist(result: Track|Artist):result is Artist {
    return (result as Artist).title !== undefined;
}

 
function isTrack(result: Track|Artist):result is boolean {
    return (result as Track).title !== undefined;
} // 오류남 필드 사용할 때 result 호출할 때 뭔지 모름 is Track 알려줘야 한다

function isArtist(result: Track|Artist):result is boolean {
    return (result as Artist).title !== undefined;
} // 오류남 


function printInfo (result:Track|Artist) {
    if(isTrack(result)) {
        console.log(result.title)
    } else if (isArtist(result)) {
        console.log(result.name)
    }
}

```


# 1) 유니온 타입의 흔한 함정

```ts
type Track = {
  title: string;        // 음원 이름
  releaseDate: string;  // 음원 발매일
};

type Artist = {
  name: string;         // 가수 이름
  releaseDate: string;  // 데뷔 날짜
};

type SearchResult = Track | Artist;

// ❌ 아래는 에러
const result: SearchResult = {
  title: "hey",
  releaseDate: "2025",
  name: "은혜",
};
```

왜 에러일까?

* 객체 리터럴을 **유니온 타입**에 바로 대입할 때는 “**초과 속성 검사(Excess Property Checks)**”가 적용돼서,

  * `Track`에는 `name`이 없고,
  * `Artist`에는 `title`이 없어,
* 두 멤버 중 **어느 하나에도 정확히 들어맞지 않기** 때문에 오류가 나와.

> 팁: 이런 경우엔 객체를 먼저 별도 변수에 담지 말고, **명확히 하나의 타입**으로 맞추거나(아래처럼 식별자를 넣기), 혹은 as-캐스트로 회피하지 말고 **타입 설계를 개선**하는 게 정석이야.

---

# 2) 식별 가능한 유니온으로 구조 잡기 (권장)

각 멤버에 공통 키(보통 `type`/`kind`)에 **리터럴 타입**을 넣어 **스스로 정체를 밝히게** 만들면, TS가 아주 똑똑하게 좁혀줘.

```ts
type Track = {
  type: "track";        // ✅ 리터럴(식별자)
  title: string;
  releaseDate: string;
};

type Artist = {
  type: "artist";       // ✅ 리터럴(식별자)
  name: string;
  releaseDate: string;
};

type Radio = {
  type: "radio";        // ✅ 리터럴(식별자)
  station: string;
};

type SearchResult = Track | Artist | Radio;
```

이제 데이터는 이렇게 **정확히 하나의 타입**을 만족하도록 만든다:

```ts
const a: SearchResult = {
  type: "track",
  title: "hey",
  releaseDate: "2025",
}; // ✅ OK

const b: SearchResult = {
  type: "artist",
  name: "은혜",
  releaseDate: "2025",
}; // ✅ OK
```

---

# 3) 안전한 분기 + “빠짐없이” 처리하기 (exhaustive check)

이미지에 있던 `getTypeName`을 **switch + never** 패턴으로 단단하게 바꿔보자.

```ts
function getTypeName(result: SearchResult) {
  switch (result.type) {
    case "track":
      return "트랙";
    case "artist":
      return "아티스트";
    case "radio":
      return "라디오";
    default:
      // 👇 여기에 도달하면 유니온 멤버가 누락된 것
      return exhaustiveCheck(result);
  }
}

function exhaustiveCheck(x: never): never {
  // 새 멤버를 추가했는데 switch에 case를 안 쓰면 여기서 컴파일 에러 발생
  throw new Error("Unhandled union member");
}
```

포인트:

* `switch (result.type)`로 **자동 좁히기**가 된다.
* `default`에서 `never`를 요구하므로, 나중에 `Podcast` 같은 새 멤버를 추가하고 **case를 빼먹으면 컴파일 단계에서 바로 경고**해줘서 버그를 줄여준다.
* 이미지 속 `if/else` 구조도 가능하지만, **`switch + never`** 조합이 가장 읽기 쉽고 빠짐없다.

---

# 4) 공통 필드/개별 필드 접근 규칙

* `releaseDate`처럼 **공통 필드**는 바로 써도 된다.
* `title`(Track 전용) / `name`(Artist 전용)처럼 **개별 필드**는 **좁힌 뒤에만** 접근해야 한다.

```ts
function printMainLine(r: SearchResult) {
  // 공통 필드 OK
  // console.log(r.releaseDate); // Track/Artist엔 있지만 Radio에는 없으니 공통으로 쓰려면 타입을 바르게 설계해야 함(예: Partial 공통, 또는 멤버별 분기)

  if (r.type === "track") {
    console.log(`곡: ${r.title}`);
  } else if (r.type === "artist") {
    console.log(`가수: ${r.name}`);
  } else {
    console.log(`라디오: ${r.station}`);
  }
}
```

> 공통 필드가 진짜로 모든 멤버에 존재해야 “바로 접근”이 가능해. 그렇지 않다면 **분기 후 접근**이 안전해.

---

# 5) 다른 좁히기 기법들 (보너스)

* **in 연산자**

  ```ts
  function isTrack(x: SearchResult): x is Track {
    return "title" in x;
  }
  ```
* **사용자 정의 타입 가드**

  ```ts
  const isArtist = (x: SearchResult): x is Artist => x.type === "artist";
  ```
* **판별 키 이름**은 `type`, `kind`, `category` 등 아무거나 가능하지만 팀에서 **컨벤션**을 정해두면 좋아.

---

# 6) 요약 템플릿 (카피해서 그대로 쓰기)

```ts
// 1) 타입 정의
type A = { type: "a"; /* ... */ };
type B = { type: "b"; /* ... */ };
type C = { type: "c"; /* ... */ };

type U = A | B | C;

// 2) 생성 예시
const u1: U = { type: "a", /* ... */ };

// 3) 안전한 분기
function handle(u: U) {
  switch (u.type) {
    case "a":
      // u는 A로 좁혀짐
      return;
    case "b":
      // u는 B로 좁혀짐
      return;
    case "c":
      // u는 C로 좁혀짐
      return;
    default:
      return exhaustiveCheck(u); // never
  }
}

function exhaustiveCheck(x: never): never {
  throw new Error("Unhandled union member");
}
```

---

