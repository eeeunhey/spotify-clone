### 제네릭 타입
타입을 변수처럼 사용할 수 있게 한다 

type ArrayType = number/string[] // 뭐가 들어가야 하나 

type ArrayType<T> = T[]
제네릭 형태 타입이다 
나중에 타입을 지정하면 지정한 타입 값으로 들어간다

const numberArray:ArrayType<number> = [1,2,3]
const stringArray:ArrayType<string>=["a","b"]
꺽쇠안에 뭘 쓰냐에 따라 그 타입으로 지정된다

언제쓰냐?
API 호출할 때 사용된다

```ts
// 카테고리 정보
{
  status: "ok",
  totalPage: 2,
  totalResult: 10,
  page: 1,
  data: [
    { name: "액션" },
    { name: "로맨스" },
    { name: "가족" },
  ],
}

// 영화 정보
{
  status: "ok",
  totalPage: 20,
  totalResult: 300,
  page: 1,
  data: [
    { title: "기생충", genre: "액션" },
    { title: "파묘", genre: "공포" },
    { title: "인사이드 아웃", genre: "가족" },
  ],
}

// TV 정보

{
  status: "ok",
  totalPage: 20,
  totalResult: 300,
  page: 1,
  data: [
    { series: "논스톱", runningTime: "120" },

  ],
}


type CategoryResponse = {
    status:sring,
    totalPage:number,
    totalResult:nubmer,
    page:number,
    data:{name:string}[]
}

type MovieResponse = {
    status:sring,
    totalPage:number,
    totalResult:nubmer,
    page:number,
    data:{title:string, genre:string}[]
}
// 겹치는것도 많은데 너무 귀찮다 이럴 때 제네릭을 써보자

type ApiResponse<T> = {
    status:sring,
    totalPage:number,
    totalResult:nubmer,
    page:number,
    data:T[]
}
//공통 부분중에 변하는 다른 부분만 받아오자

type CategoryResponse = ApiResponse<{name:string}>
// 안에 있는 name:string이 전달된다

type Category={
    name:string;
}

type Movie={
    title:string,
    genre:string,
}

type CategoryResponse = ApiResponse<Category>
type MovieResponse = ApiResponse<Category>
//훨씬 간결하고 편하게 사용할 수 있다

let MovieData:MovieResponse={
    status:"ok",
    totalPage:20,
    totalResult:300,
    page:1,
    data:[
        { title: "기생충", genre: "액션" },
        { title: "파묘", genre: "공포" },
        { title: "인사이드 아웃", genre: "가족" },
    ]
}

```

리액트 useState도 제네릭 타입이다

```js
function useState(초기값) {
    return [값, 함수]
}
const [value,setValue]=useState(2)
const[value2, setvalue2] = useState("안녕")

function useState(초기값:user가 뭘 넣을지 모르는 상태)
function useState<T>(초기화값:T):[T,함수<T>]


```

### 제네릭 값 제한

interface Length {
    length:number
}

function getValue<T extends Length >(data:T){
    console.log(data.length)
}
무슨타입이 들어올지는 모르지만 무조건 length는 있어야 한다 
무조건 길이가 있는 형태를 넣어줘야한다 

### 제네릭 고급 타입
1. 조건부 타입
type IsStgring<T>= T extends string ? "yes":"no"

type result1 = IsStgring<number> 
no를 보여준다

2. mapped type
이중에 특정 정보만 가져오고 싶다 
옵셔널 지정 시 기존 데이터가 필요할 때 나중에 문제가 발생
옵셔널한 타입을 따로 만든다


type Movie={
    title:string;
    genre:string;
    rate:number;
}

const movie:Movie={ title: "기생충", genre: "액션" }
const movie:Movie={ rate: 2}

옵셔널한 타입을 따로 만든다 뒤에 있는 타입형태를 인식

type MovieSubset={
    title?:string;
    genre?:string;
    rate? :number;
}

type Subset<T>={
    [K in keyof T]?:T[K] // 해당 키값을 가져온다
   readonly [K in keyof T]?:T[K]
}
const movie:Subset<Movie>={ title: "기생충", genre: "액션" }
const movie:Subset<Movie>={ rate: 2},


### 다중 제네릭 사용하기

interface Pair<T, U> {
    first:T,
    second:U,
    display():void  //일반함수
    display:()=>void // 화살표 함수
}

const pari : Pair<String, number>={
    first:"eunhye",
    second:23,
    display(){
        console.log(this.first+"는"+this. second+"살 이다")
    }
}
pair.display()